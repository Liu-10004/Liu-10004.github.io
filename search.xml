<?xml version="1.0" encoding="utf-8"?>
<search>
    
    
    <entry>
        <title><![CDATA[React基础]]></title>
        <url>http://yoursite.com/2017/06/04/React/</url>
        <content type="html"><![CDATA[<p>###React</p>
<blockquote>
<p>React中有两大核心组件：</p>
<ul>
<li>react：核心库 (React)</li>
<li>react-dom：提供与DOM相关的功能 (ReactDOM)</li>
</ul>
<p>npm install react react-dom –save-dev</p>
</blockquote>
<p>####1、JSX和DOM操作</p>
<pre><code>//-&gt;在入口中导入CSS,使用WEB-PACK编译部署
require(&apos;./css/index.css&apos;);

//-&gt;导入需要的模块(ES6语法)
import React from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;

let app = document.getElementById(&apos;app&apos;);
let styleObj = {color: &apos;red&apos;},
    personList = [&apos;张三&apos;, &apos;李四&apos;, &apos;王五&apos;];

ReactDOM.render(&lt;h1 style={styleObj} className=&quot;title&quot;&gt;
    hello world!
    &lt;ul&gt;
        {
            personList.map((item, index)=&gt; {
                return &lt;li key={index}&gt;{item}&lt;/li&gt;;//-&gt;需要给每一个元素设置唯一标识key，存储的值不相同才可以
            })
        }
    &lt;/ul&gt;
&lt;/h1&gt;, app);
</code></pre><blockquote>
<p>JSX：javascript + xml(html) 它是React独有的语法，我们使用这样的语法创建虚拟的DOM，在最后部署打包的时候，基于babel-loader把ES6-&gt;ES5，把JSX变为HTML</p>
<ul>
<li>所有看起来像标签，但不是HTML标签的都是虚拟DOM(React元素)</li>
<li>所有使用 {…}  包起来的都是JS语法</li>
<li>设置样式有两种方式：<ul>
<li>使用行内style来操作  style={styleObj} 我们需要把样式都使用一个变量提前定义</li>
<li>使用样式类名来操作  className=”title”</li>
</ul>
</li>
</ul>
<p>当我们执行ReactDOM.render方法的时候，React会按照上面的机制，把虚拟DOM已经我们编写的JS进行解析，然后把结果插入到app容器中，此时原有的虚拟DOM变为了真实的DOM</p>
</blockquote>
<p>####2、React组件</p>
<blockquote>
<p>React的优势就在于组件化的定制，我们可以制定很多的组件，最后一个完整的页面就是由N多个组件组成的，这个也是我们前端工程化开发的意思所在。</p>
</blockquote>
<p>#####定义组件</p>
<pre><code>/*
    使用ES6语法定义组件

    1.使用的是ES6中的继承，React.Component就是React的组件类，我们创建的新的组件是Person，我们让其继承React.Component

    2.我们自己的定义的组件名，第一个首字母必须大写(React规定)，而且每一个组件有且只能有一个顶级标签

    3.render是规定的方法，在这个方法中返回我们组件的虚拟DOM即可，而对于constructor以及它的参数，我们后续再介绍
*/
class Person extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        return &lt;h1 className=&quot;title&quot;&gt;
            人员名单
            &lt;ul&gt;
                {
                    personList.map((item, index)=&gt; {
                        return &lt;li key={index}&gt;{item}&lt;/li&gt;;
                    })
                }
            &lt;/ul&gt;
        &lt;/h1&gt;;
    }
}

/*
    我们使用ReactDOM.render方法可以把自定义的组件增加到页面指定的容器中，这样虚拟DOM就变为了真实的DOM
*/
ReactDOM.render(&lt;Person/&gt;, app);
</code></pre><p>#####组件的属性</p>
<blockquote>
<p>属性是一个组件基础信息，在调取组件的时候，由父级组件指定相关的属性值，然后在子组件中，我们只能获取这些属性值，但是不可以修改这些属性值</p>
</blockquote>
<pre><code>class Person extends React.Component {
    //-&gt;在构造函数中需要把props这个组件的属性进行继承
    constructor(props) {
        super(props);
    }

    render() {
        //-&gt;我们可以使用 this.props.xxx 来获取传递进来的属性值
        return &lt;div&gt;
            {this.props.name}&lt;br/&gt;
            {this.props.age}&lt;br/&gt;
            {this.props.sex}
        &lt;/div&gt;;
    }
}

//-&gt;配置组件属性的默认值或者称之为配置默认属性，在ES5语法中是一个方法：getDefaultProps
Person.defaultProps = {
    name: &apos;--&apos;,
    age: 25,
    sex: &apos;man&apos;
};

//-&gt;在插入组件到页面容器中的时候，我们根据需求把要求的属性填写上：name=&quot;张三&quot; age=&quot;30&quot; ... 不填写的按照默认值defaultProps处理即可
ReactDOM.render(&lt;Person name=&quot;张三&quot; age=&quot;30&quot;/&gt;, app);
</code></pre><p>#####this.props.children </p>
<blockquote>
<p>在父级组件中导入子组件，我们使用双闭合标签语法，可以在展开的块级区域中创建“子元素”，这些内容都会设定在props.children 上，这样我们就可以在组件中使用这些内容了</p>
</blockquote>
<pre><code>class Person extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        return &lt;div&gt;
            我的朋友
            {
                React.Children.map(this.props.children, (child)=&gt; {
                    return child;
                })
            }
        &lt;/div&gt;;
    }
}
ReactDOM.render(&lt;Person&gt;
    &lt;span&gt;张三&lt;/span&gt;
    &lt;span&gt;李四&lt;/span&gt;
    &lt;span&gt;王五&lt;/span&gt;
&lt;/Person&gt;, app);
</code></pre><p>#####状态</p>
<blockquote>
<p>组件的状态就像人的心情，会经常变化，而且只能由自己来改变<br>组件一开始有一个初始状态,然后用户互动,导致状态变化，从而触发界面重新渲染<br>可以给按钮绑定事件，当事件发生的时候调用对应的方法改变组件的状态</p>
</blockquote>
<pre><code>class Person extends React.Component {
    constructor(props) {
        super(props);
        //-&gt;设置默认的状态信息
        this.state = {
            happy: true
        }
    }

    fn(e) {
        //-&gt;重新设置state值
        this.setState({
            happy: !this.state.happy
        });
    }

    render() {
        var happyState = this.state.happy ? &apos;good&apos; : &apos;bad&apos;;
        return &lt;div&gt;
            today is {happyState} day!
            &lt;input type=&quot;button&quot; value=&quot;change&quot; onClick={this.fn.bind(this)}/&gt;
            //-&gt;ES6中的一个坑：一定要重新的bind(this)，这样在方法中的this才代表这个组件，否则代表的是当前点击的这个元素
        &lt;/div&gt;;
    }
}
ReactDOM.render(&lt;Person/&gt;, app);
</code></pre><blockquote>
<p>剪贴板事件 onKeyDown onKeyPress onKeyUp<br>键盘事件 onFocus onBlur<br>焦点事件 onChange onInput onSubmit<br>鼠标事件 onClick onDoubleClick onMouseDown onMouseEnter onMouseLeave</p>
</blockquote>
<p>#####表单元素双向数据绑定<br>    class Person extends React.Component {<br>        constructor(props) {<br>            super(props);<br>            this.state = {<br>                value: 0<br>            };<br>        }</p>
<pre><code>    handleChange(e) {
        this.setState({
            value: e.target.value
        });
    }

    render() {
        var value = this.state.value;
        return &lt;div&gt;
            &lt;input style={{color: 'red'}} type=&quot;text&quot;
                   value={value} onChange={this.handleChange.bind(this)}/&gt;
            &lt;p&gt;{value}&lt;/p&gt;
        &lt;/div&gt;;
    }
}
ReactDOM.render(&lt;Person/&gt;, app);
</code></pre><blockquote>
<p>如果给表单元素设置了value属性，则必须指定onChange事件处理函数，否则 此字段会变成只读状态</p>
</blockquote>
<p>#####复合组件 </p>
<blockquote>
<p>多个简单的组件嵌套，可构成一个复杂的复合组件，从而完成复杂的交互逻辑</p>
</blockquote>
<pre><code>class Panel extends React.Component {
    render() {
        return &lt;div className=&quot;panel panel-default&quot;&gt;
            &lt;PanelHead head={this.props.head}/&gt;
            &lt;PanelBody body={this.props.body}/&gt;
        &lt;/div&gt;;
    }
}
class PanelHead extends React.Component {
    render() {
        return &lt;div className=&quot;panel-heading&quot;&gt;
            {this.props.head}
        &lt;/div&gt;;
    }
}
class PanelBody extends React.Component {
    render() {
        return &lt;div className=&quot;panel-body&quot;&gt;
            {this.props.body}
        &lt;/div&gt;;
    }
}
ReactDOM.render(&lt;Panel head=&quot;头部&quot; body=&quot;正文&quot;/&gt;, app);
</code></pre><p>#####DOM操作 </p>
<blockquote>
<p>给组件加上ref=”xxx”后，可在父组件中通过this.refs.xxx获取该DOM元素</p>
</blockquote>
<pre><code>class Panel extends React.Component {
    handleClick(e) {
        this.refs.msg.focus();
    }

    render() {
        return &lt;div&gt;
            &lt;input type=&quot;text&quot; ref=&quot;msg&quot;/&gt;
            &lt;input type=&quot;button&quot; value=&quot;获得焦点&quot;
                   onClick={this.handleClick.bind(this)}/&gt;
        &lt;/div&gt;;
    }
}
ReactDOM.render(&lt;Panel/&gt;, app);
</code></pre>]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[数据类型检测]]></title>
        <url>http://yoursite.com/2017/06/04/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/</url>
        <content type="html"><![CDATA[<h2 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h2><h3 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a>1、typeof</h3><ul>
<li>功能:检测数据类型</li>
<li>返回值：字符串，字符串中包含了对应的数据类型，例如：‘number’</li>
<li>局限性：<ul>
<li>typeof null-&gt;’object’  </li>
<li>不能具体的细分具体的对象</li>
</ul>
</li>
</ul>
<h3 id="2、instanceof"><a href="#2、instanceof" class="headerlink" title="2、instanceof"></a>2、instanceof</h3><ul>
<li><p>功能：检测实例是否属于某个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj=[1,2]</div><div class="line">obj instanceof(Array);//true</div><div class="line">obj instanceof(Object);//true</div></pre></td></tr></table></figure>
</li>
<li><p>返回值：Boolean</p>
</li>
<li>局限性：<ul>
<li>1、不能检测和处理字面量方式创建出来的==基本数据类型==值（对于基本数据类型来说，字面量方式创建出来的结果和实例创建的结果是有一定区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这个类的一个实例；对于字面量方式创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于JS的松散特点，导致了可以使用Number.prototy上提供的方法）</li>
<li>2、只要在当前实例的原型链上，我们检测出来的结果都是true</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;&quot; instanceof String;//false</div><div class="line">1 instanceof Number;//false</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var str=&apos;&apos;;</div><div class="line">str instanceof String；//false</div><div class="line">var ary=[];</div><div class="line">ary instanceof Array;//true</div><div class="line">ary instanceof Object;//true</div></pre></td></tr></table></figure>
<h3 id="3、constructor-构造函数"><a href="#3、constructor-构造函数" class="headerlink" title="3、constructor 构造函数"></a>3、constructor 构造函数</h3><ul>
<li>功能：和instanceof类似,但是它能处理字面量创建出来的数据类型值</li>
<li>返回值：constructor的指向的类（函数数据类型）</li>
<li>局限性：我们可以把类的原型进行重写，在重写的过程中，可能把之前的constructor覆盖了，这样检测出来的结果不准确<blockquote>
<p>==对于特殊的数据类型null和undefined，他们的所属类是Null和Undefined，但是浏览器把这两个类保护起来了，不允许我们放在外面访问使用==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var obj=[];</div><div class="line">obj.constructor===Array;//true</div><div class="line">obj.constructor===RegExp;//false</div><div class="line">var num=1;</div><div class="line">num.constructor===Number;//true</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="4、Oject-prototype-toString-call"><a href="#4、Oject-prototype-toString-call" class="headerlink" title="4、Oject.prototype.toString.call()"></a>4、Oject.prototype.toString.call()</h3><ul>
<li>功能：最准确的检测数据类型方法</li>
<li>返回值：”[object,xxx]” <ul>
<li>xxx代表被检测的数据类型具体属于哪个类<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object.prototype.toString.call([]);//&quot;[object Array]&quot;</div><div class="line">Object.prototype.toString.call(/^$/);//&quot;[object Regexp]&quot;</div><div class="line">Object.prototype.toString.call(&apos;&apos;);//&quot;[object String]&quot;</div><div class="line">Object.prototype.toString.call(true);//&quot;[object Boolean]&quot;</div><div class="line">Object.prototype.toString.call(null);//&quot;[object Null]&quot;</div><div class="line">Object.prototype.toString.call(undefined);//&quot;[object Undefined]&quot;</div><div class="line">Object.prototype.toString.call(function()&#123;&#125;);//&quot;[object Function]&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="toString的理解："><a href="#toString的理解：" class="headerlink" title="toString的理解："></a>toString的理解：</h3><p>字面上理解是，转换为字符串，但是并不是所有的toString都代表了转换字符串</p>
<blockquote>
<p>对于Number、Boolean、String、Array、Regexp、Date、Function上的toString方法都代表转换字符串，而Object上的toString方法并不是来转换字符串的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Number上的toString转化为字符串</div><div class="line">(1).toString();//Number.prototype.toString();</div><div class="line">(1).__proto__.toString();//Number.prototype.toString();</div><div class="line">(1).__proto__.__proto__.toString();//Object.prototype.toString()</div><div class="line">//Number上的toString转化为进制</div><div class="line">(128).toString(1/10/8)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//String上的toString转化为字符串</div><div class="line">//Boolean上的toString转换为对应字符串 &quot;true&quot; &quot;false&quot;</div><div class="line">//null和undefined没有toString方法</div><div class="line">//Array的toString方法转化为字符串</div><div class="line">//Regexp的toString方法转化为字符串</div><div class="line">/\d+/.toString;  //   &apos;/\d+/&apos;</div><div class="line">Date上的toString方法是转化字符串</div><div class="line">new Date().toString();//&quot;Fri Feb 24 2017 21:47:43 GMT+0800 (中国标准时间)&quot;</div><div class="line">Math.toString();//&quot;[object Math]&quot;</div></pre></td></tr></table></figure>
<p>Array.isArray()  检测是否是数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Array.isArray([]);//true</div><div class="line">Array.isArray(&apos;&apos;);//false</div></pre></td></tr></table></figure></p>
]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[node基础]]></title>
        <url>http://yoursite.com/2017/06/04/node%E5%9F%BA%E7%A1%80/</url>
        <content type="html"><![CDATA[<h2 id="node基础"><a href="#node基础" class="headerlink" title="node基础"></a>node基础</h2><p>在官网下载最新的node，安装时最好装在C盘<br>安装过程中，都是默认选项，不用更改</p>
<h4 id="node优点"><a href="#node优点" class="headerlink" title="node优点"></a>node优点</h4><ul>
<li>node 主线程是单线程的，进程中包含线程，正常java一个进程中包含多个线程，node中一个进程只能包含一个线程，允许开子进程<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4></li>
<li>代码从上到下执行，先走同步再走异步，异步不会阻塞主线程<h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4></li>
<li>针对内核来说，非阻塞是异步的前置条件，（指的是厨师，如果厨师拉着服务员聊天，那么他就无法服务顾客，最后整个进程就会挂掉了）<blockquote>
<p>前端的异步：定时器，回调，事件绑定，ajax<br>node中的异步： 异步的文件读写，callback，定时器</p>
<h4 id="事件环"><a href="#事件环" class="headerlink" title="事件环"></a>事件环</h4></blockquote>
</li>
</ul>
<h2 id="node对象"><a href="#node对象" class="headerlink" title="node对象"></a>node对象</h2><p>global上的属性</p>
<h3 id="在node环境下的坑-全局的this问题"><a href="#在node环境下的坑-全局的this问题" class="headerlink" title="在node环境下的坑(全局的this问题)"></a>在node环境下的坑(全局的this问题)</h3><ul>
<li>下面都是全局属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(this); //&#123;&#125;=module.exports=exports   因为每个文件执行前，会套用一个闭包函数，本来指向的是global，因为这个函数，在这个函数中this指向发生了改变</div><div class="line">(function()&#123;</div><div class="line">	console.log(this)//global</div><div class="line">	&#125;)()</div><div class="line">	//自执行函数中的this=global</div><div class="line">var a=100;//用var声明的不会挂载在global上</div><div class="line">console.log(global.a)//这是得不到a的</div></pre></td></tr></table></figure>
</li>
</ul>
<p>记录时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var timer1=Date.now();</div><div class="line">for(var i=0;i&lt;10000000;i++)&#123;</div><div class="line">&#125;</div><div class="line">var timer2=Date.now()-timer1;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>setTimeout的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function eatrice(who,who1)&#123;</div><div class="line">    console.log(who+&apos;吃米饭&apos;+who1);</div><div class="line">&#125;</div><div class="line">setTimeout(eatrice,1000,&apos;我&apos;,&apos;你&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>setTimeout中的this问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(function ()&#123;</div><div class="line">    console.log(this)</div><div class="line">&#125;,1000)//这里的this是setTimeout本身</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">每个模块都是一个单独的作用域,通过闭包的形式产生独立作用域</div><div class="line">(function (exports,require,module,__filename,__dirname)&#123;</div><div class="line">return module.exports;</div><div class="line">//全局对象</div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
<p>进程process<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">setTimeout(function ()&#123;</div><div class="line">&#125;,100000)</div><div class="line">setTimeout(function ()&#123;</div><div class="line">    process.kill(process.pid)//杀死当前进程，也可以操作其他的进程，比如QQ</div><div class="line">&#125;,5000)</div><div class="line">setTimeout(function ()&#123;</div><div class="line">    process.exit(process.pid)/退出进程</div><div class="line">&#125;,5000)</div></pre></td></tr></table></figure></p>
<h3 id="js中的模块"><a href="#js中的模块" class="headerlink" title="js中的模块()"></a>js中的模块()</h3><ul>
<li>1、文件模块  引用方式（./    ../）</li>
<li>2、第三方模块</li>
<li>3 、核心模块（内置模块）</li>
<li><p>（seajs cmd,requirejs amd,node commonjs）</p>
<blockquote>
<p>cmd 就近依赖，amd依赖前置</p>
</blockquote>
</li>
<li><p>单例（不能保证完全解决冲突，调用时，调用名字过长）</p>
</li>
<li>闭包，node中实现模块化，采用的是读写<h3 id="commonjs（提高了可维护性，有利于分工协作，高内聚低耦合）"><a href="#commonjs（提高了可维护性，有利于分工协作，高内聚低耦合）" class="headerlink" title="commonjs（提高了可维护性，有利于分工协作，高内聚低耦合）"></a>commonjs（提高了可维护性，有利于分工协作，高内聚低耦合）</h3></li>
<li>如何定义模块<br>创建一个js文件，每个文件就是一个模块，多个模块可以组成一个包</li>
<li><p>如何导出一个模块   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Fn ()&#123;&#125;;</div><div class="line">exports/module.exports</div><div class="line">//exports或者module.exports本身是一个对象，可以把需要导出的函数Fn挂载在这个对象上</div><div class="line">exports.a=Fn;</div><div class="line">或者module.exports=Fn;</div></pre></td></tr></table></figure>
</li>
<li><p>如何使用一个模块</p>
<blockquote>
<p>require,一般是同步的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var import=require(&apos;./1.js&apos;);//同步的</div><div class="line">---require(&apos;./1.js&apos;,function()&#123;&#125;)//有回调就是异步的---</div><div class="line">import.a()//即Fn执行</div><div class="line">//import();对应上面的odule.exports=Fn;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer是全局属性</p>
<ul>
<li>缓冲区Buffer是暂时存放输入输出数据的一段内存。</li>
<li>Buffer展现给我们的是16进制的</li>
<li>一个汉字有两个字节（utf8格式的有三个字节）</li>
<li>一个字节有八个位组成 </li>
</ul>
<p>1、创建buffer 三种方式（固定大小），非常像数组   会将buffer转换成字符串</p>
<ul>
<li>长度创建 、 字符串创建、  数组创建（数组里的数字，在0-255之间）<h4 id="Buffer常用方法"><a href="#Buffer常用方法" class="headerlink" title="Buffer常用方法"></a>Buffer常用方法</h4></li>
<li>fill方法<br>手动把buffer内容清0<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">buffer.fill(0)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>-copy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var buffer = new Buffer(12);</div><div class="line">var buf1 = new Buffer(&apos;珠峰&apos;);</div><div class="line">var buf2 = new Buffer(&apos;培训&apos;);</div><div class="line">//targetBuffer,目标buffer targetStart,目标的开始 sourceStart,源的开始 sourceEnd源的结束</div><div class="line">buf1.copy(buffer,0);</div><div class="line">buf2.copy(buffer,6);</div></pre></td></tr></table></figure></p>
<ul>
<li><p>用copy封装的copy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//1.myConcat list totalLength</div><div class="line">//2.判断长度是否传递，如果给了长度就构建一个buffer,将小buffer依次拷贝到大buffer上，过长则将多余的部分 截取掉slice()截取有效长度</div><div class="line">//3.手动维护长度 在构建buffer，将小buffer依次拷贝到大buffer上 copy</div><div class="line">var buf1 = new Buffer(&apos;珠峰&apos;);</div><div class="line">var buf2 = new Buffer(&apos;培训&apos;);</div><div class="line">Buffer.myConcat = function (list,totalLength) &#123;</div><div class="line">    //1.判断长度是否传递</div><div class="line">    if(typeof totalLength == &quot;undefined&quot;)&#123;</div><div class="line">        totalLength = 0;</div><div class="line">        list.forEach(function (item) &#123;</div><div class="line">            totalLength += item.length;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    var buffer = new Buffer(totalLength);//1000</div><div class="line">    var index = 0;</div><div class="line">    list.forEach(function (item) &#123;</div><div class="line">        item.copy(buffer,index);</div><div class="line">        index+= item.length;</div><div class="line">    &#125;);</div><div class="line">    return buffer.slice(0,index);</div><div class="line">&#125;;</div><div class="line">console.log(Buffer.concat([buf1,buf2,buf1,buf2]).toString());</div></pre></td></tr></table></figure>
</li>
<li><p>write方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">buffer.write(string, offset, length, encoding)</div><div class="line">buffer.write(&apos;珠&apos;,0,3,&apos;utf8&apos;);</div><div class="line">buffer.write(&apos;峰&apos;,3,3,&apos;utf8&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>toString方法<br>把buffer转换成字符串类型 ，start  ，end是截取的buffer的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">buffer.toString(&apos;utf8&apos;,3,6);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><ul>
<li><p>将任意进制字符串装换为十进制</p>
<ul>
<li>parseInt(“11”, 2); // 3 2进制转10进制</li>
<li>parseInt(“77”, 8); // 63 8进制转10进制</li>
<li>parseInt(“e7”, 16); //175 16进制转10进制</li>
</ul>
</li>
<li><p>将10进制转换为其它进制字符串</p>
<ul>
<li>(3).toString(2)) // “11” 十进制转2进制</li>
<li>(17).toString(16) // “11” 十进制转16进制</li>
<li>(33).toString(32) // “11” 十提制转32进制</li>
</ul>
</li>
<li>base64的转换<br>图片用webpack打包压缩后，都是base64的<br>base64 不是一个加密算法， 加密 md5 sha1 sha256<br>将汉字转换成base64 ‘珠’ =&gt; 54+g  3<em>8 = 6</em>4<br>2进制装换成10进制不得大于64,得到的结果在可见编码中取值<h2 id="fs（核心模块）"><a href="#fs（核心模块）" class="headerlink" title="fs（核心模块）"></a>fs（核心模块）</h2>能用异步，就不用同步，同步容易造成线程阻塞</li>
<li><p>read<br>readFile会淹没可用内存，不能读取比内存大的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var fs=require(&apos;fs&apos;);</div><div class="line">var school = &#123;&#125;; //计数器的原理</div><div class="line">fs.readFile(&apos;./name.txt&apos;,&apos;utf8&apos;,function (e,data) &#123; //error-first</div><div class="line">    if(e)console.log(e);</div><div class="line">    school.name = data;</div><div class="line">    out();</div><div class="line">&#125;);</div><div class="line">fs.readFile(&apos;./age.txt&apos;,&apos;utf8&apos;,function (e,data) &#123; //error-first</div><div class="line">    if(e)console.log(e);</div><div class="line">    school.age = data;</div><div class="line">    out();</div><div class="line">&#125;);</div><div class="line">function out() &#123;</div><div class="line">    if(Object.keys(school).length == 2)&#123;</div><div class="line">        console.log(school); //&#123;name:&apos;珠峰培训&apos;,age:8&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>write</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//1.如果写的文件不存在会创建文件</div><div class="line">//2.默认写入格式是utf8格式</div><div class="line">//3.文件有内容，清空文件内容</div><div class="line">//fs.writeFileSync(&apos;./a.txt&apos;,new Buffer(&apos;珠峰&apos;));</div><div class="line">//如果放入的是buffer格式 会默认toString(&apos;utf8&apos;);</div><div class="line">fs.writeFile(&apos;./a.txt&apos;,new Buffer(&apos;珠峰培训&apos;),function (err) &#123;</div><div class="line">    console.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function copySync(source,target)&#123;</div><div class="line">   var content= fs.readFileSync(source);</div><div class="line">   fs.writeFileSync(target,content);</div><div class="line">&#125;</div><div class="line">copySync(&apos;./name.txt&apos;,&apos;./name1.txt&apos;);</div></pre></td></tr></table></figure>
<ul>
<li><p>追加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//write方法，一般是先把文件内容清空，然后重新写入</div><div class="line">function copy(source,target) &#123;//异步</div><div class="line">    //先读在写</div><div class="line">    fs.readFile(source,function (err,data) &#123;</div><div class="line">        if(err)console.log(err);</div><div class="line">        //appendFile可以进行累加，不清空内容写入</div><div class="line">        //fs.appendFile(target,data,function (err) &#123;&#125;)</div><div class="line">            if(err)console.log(err);</div><div class="line">            console.log(&apos;拷贝成功&apos;);</div><div class="line">        &#125;);</div><div class="line">        fs.writeFile(target,data,&#123;encoding:&apos;utf8&apos;,flag:&apos;a&apos;&#125;,function (err) &#123;</div><div class="line">            if(err)console.log(err);</div><div class="line">            console.log(&apos;拷贝成功&apos;);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>path （path模块）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const path=require(&apos;path&apos;);</div><div class="line">console.log(path.resolve(&apos;1.js&apos;));//以当前路径解析出一个相对路径</div><div class="line">console.log(path.join(__dirname,&apos;1.js&apos;));//相当于resolve,__dirname 当前文件所在目录的绝对路径</div></pre></td></tr></table></figure>
</li>
<li><p>mkdirSync   mkdir 创建目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mkdir -p a/a1/a2/a3/a4/a5   可以连续创建，不加-p只能一层层手动创建（这是命令行操作，不能作为js里的代码来执行）</div><div class="line">var fs=require(&apos;fs&apos;);</div><div class="line">function makep(p)&#123;</div><div class="line">    var ary=p.split(&apos;/&apos;);</div><div class="line">    var dir=&apos;&apos;;</div><div class="line">    ary.forEach(function (item)&#123;</div><div class="line">       // console.log(typeof item)</div><div class="line">       dir+=item+&apos;/&apos;;</div><div class="line">       fs.mkdirSync(dir);</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line">makep(&apos;a/b/c/d/e/f&apos;)</div></pre></td></tr></table></figure>
</li>
<li><p>rmdirSync   rmdir   删除目录</p>
</li>
<li>unlinkSync unlink  删除文件</li>
<li>readdirSync  readdir  读取目录</li>
<li>existsSync  exists   是否存在</li>
<li>statSync  stat   判断文件</li>
</ul>
<h3 id="观察者模式（订阅发布）"><a href="#观察者模式（订阅发布）" class="headerlink" title="观察者模式（订阅发布）"></a>观察者模式（订阅发布）</h3><p>主要思想：在原型上用on来绑定一个方法，发布用emit来发布，用removeListener来解除绑定，用once方法解决重复发布的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">function Man() &#123;</div><div class="line">    this._events = &#123;&#125;;</div><div class="line">&#125;</div><div class="line">Man.prototype.on = function (eventName,callback) &#123;</div><div class="line">    if(this._events[eventName])&#123;//这是第二次 &#123;“有钱”:[买车,买房]&#125;</div><div class="line">        this._events[eventName].push(callback);</div><div class="line">    &#125;else&#123; //这是第一次 &#123;“有钱”:[买车]&#125;</div><div class="line">        this._events[eventName] = [callback];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Man.prototype.emit = function (eventName,...args) &#123;</div><div class="line">    //console.log([].slice.call(arguments,1));</div><div class="line">    //console.log(Array.from(arguments).slice(1));</div><div class="line">    if(this._events[eventName])&#123; //如果有 ，才执行</div><div class="line">        this._events[eventName].forEach( callback =&gt;&#123;</div><div class="line">            callback.apply(this,args);//执行数组中的函数</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;//&#123;有钱:[&apos;买车&apos;,&apos;买房&apos;]&#125;</div><div class="line">Man.prototype.removeListener = function (eventName,callback) &#123;</div><div class="line">    if(this._events[eventName])&#123;</div><div class="line">        this._events[eventName] = this._events[eventName].filter(function (cb) &#123;</div><div class="line">            //返回true表示 这一项留下 false表示这一项删除</div><div class="line">            return cb!=callback;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Man.prototype.once = function (eventName,callback) &#123;</div><div class="line">    //先绑定事件，当emit触发后移除绑定的函数</div><div class="line">&#125;;</div><div class="line">var man = new Man();</div><div class="line">function buyCar(who) &#123;console.log(`给$&#123;who&#125;买车`)&#125;</div><div class="line">function buyHouse(who) &#123;console.log(`给$&#123;who&#125;买车房`)&#125;</div><div class="line">man.once(&apos;有钱&apos;,buyCar); //只执行一次,触发一次后，在数组中删除买车的事件</div><div class="line">man.on(&apos;有钱&apos;,buyHouse); //&#123;&quot;有钱&quot;:[&quot;买车&quot;]&#125;</div><div class="line">man.removeListener(&apos;有钱&apos;,buyHouse);</div><div class="line">man.emit(&apos;有钱&apos;,&apos;妹子&apos;);</div><div class="line">man.emit(&apos;有钱&apos;,&apos;妹子&apos;);</div><div class="line">man.emit(&apos;有钱&apos;,&apos;妹子&apos;);</div><div class="line">man.emit(&apos;有钱&apos;,&apos;妹子&apos;);</div></pre></td></tr></table></figure></p>
]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[git]]></title>
        <url>http://yoursite.com/2017/06/04/git/</url>
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>-git安装</p>
<blockquote>
<p>在安装时，只有一项需要自己手动选择（选择通过git和unix命令行来操作），其他都是选择默认的。</p>
<h3 id="svg与git的区别"><a href="#svg与git的区别" class="headerlink" title="svg与git的区别"></a>svg与git的区别</h3><ul>
<li>svg是用户必须通过网络发送到中央服务器中，中央服务器挂掉后，所有代码丢失。属于集中式</li>
<li>git是用户先放在自己本地，某个用户更改代码时，通知其他用户，跟服务器关系不大，属于分布式<h2 id="本地的操作方法"><a href="#本地的操作方法" class="headerlink" title="本地的操作方法"></a>本地的操作方法</h2><h4 id="git-操作"><a href="#git-操作" class="headerlink" title="git 操作"></a>git 操作</h4>全局配置用户名<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global user.name Liubingqun  //用户名可更改，一般是我们git的用户名</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>配置邮箱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global user.name 1959960001@qq.com//可更改，一般是我们的用户git邮箱</div></pre></td></tr></table></figure></p>
<p>查看详细的配置信息（包括用户名，用户邮箱。。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --list</div></pre></td></tr></table></figure></p>
<p>创建目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir gitTest &amp;&amp; cd gitTest//创建并打开</div></pre></td></tr></table></figure></p>
<p>再当前文件夹下初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init//表示该文件将要被git管理</div></pre></td></tr></table></figure></p>
<p>查看当前文件夹下所有的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al //查看所有的问价包括隐藏文件</div></pre></td></tr></table></figure></p>
<p>在当前文件夹下创建新的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">touch index.txt</div><div class="line">vi index.txt//在此文件下编写内容</div><div class="line">输入i命令，此时可以输入</div><div class="line">输入完成时，按esc键，输入:wq，退出并保存</div><div class="line">q! 强制退出</div><div class="line">rm index.txt //删除此文件</div></pre></td></tr></table></figure></p>
<p>查看git状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>把当前文件夹下的文件放入暂存区中（操作的是本地，不需要连网）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add .  //.代表当前文件夹下所有的文件</div></pre></td></tr></table></figure></p>
<p>把文件放入版本库中（操作的是本地，不需要连网）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &apos;&apos;//引号中放入一些的信息</div></pre></td></tr></table></figure></p>
<p>查看git日志（针对的是版本库）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line">//显示历史版本</div></pre></td></tr></table></figure></p>
<p>对比代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git diff //默认比较的是工作区和暂存区</div><div class="line">git diff --cached //暂存区和版本库对比</div><div class="line">git diff 分支名 // 当前工作区和版本库的对比，默认分支名是master</div></pre></td></tr></table></figure></p>
<h4 id="后续操作（回滚）"><a href="#后续操作（回滚）" class="headerlink" title="后续操作（回滚）"></a>后续操作（回滚）</h4><p>回滚，在工作区修改并提交到了暂存区中，但是后悔了，想用回滚到以前的版本（这个操作针对的是暂存区）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset HEAD . //暂存区的文件回滚到上一个版本</div></pre></td></tr></table></figure></p>
<p>把暂存区的文件拉到工作区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout 文件名</div></pre></td></tr></table></figure></p>
<p>在版本库中回滚到过去的版本（工作区和暂存区和版本区同时生效），硬回滚<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard 版本号（dea3b25a02c4106b917e860bbe8ecad8d63fff55）</div></pre></td></tr></table></figure></p>
<p>回滚后查看版本库历史所有的版本号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure></p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git branch  //查看分支 master</div><div class="line">git branch ddd // 创建分支ddd</div><div class="line">git checkout ddd //把当前分支切换到ddd分支上</div><div class="line">git checkout -b ddd//更快捷的操作，创建并切换到这个分支</div><div class="line">//刚创建出来的ddd,它里面的内容和master一模一样,相当于克隆一份</div><div class="line">在当前的文件夹下创建文件1.js， 那么这个文件和master无关，和ddd也无关，推送到哪个分支上就属于哪个分支的</div></pre></td></tr></table></figure>
<p>删除分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout master //先切换到另一个分支</div><div class="line">git branch -D ddd// 然后再删除这个分支</div><div class="line">//如果在当前分支上，是不能删除此分支，必须先切换到另一个分支上</div></pre></td></tr></table></figure></p>
<p>合并<br>ddd合并到master上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">先切换到master上，</div><div class="line">git merge ddd</div></pre></td></tr></table></figure></p>
<p>查看结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --graph</div></pre></td></tr></table></figure></p>
<p>冲突</p>
<ul>
<li>同样的文件在master上存在，在分支ddd上也有，但是文件内容不同，当分支合并到主支时，会出现冲突，解决办法就是手动解决</li>
</ul>
<h2 id="在git端操作"><a href="#在git端操作" class="headerlink" title="在git端操作"></a>在git端操作</h2><p>本地一般要建一个README.md  .gitignore<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo &apos;welcome&apos; &gt;READ.MD</div><div class="line">echo &apos;.idea&apos; &gt; .gitignore</div><div class="line">git log --grep=me//搜素commit中带me的</div><div class="line">git log --author=zf//搜素作者中带‘zf’的</div></pre></td></tr></table></figure></p>
<ul>
<li>提交并配置远端的地址<br><strong>提交的是master</strong>,所以要切换到master上<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git add . //暂存区</div><div class="line">git commit -m &apos;&apos;  //版本库</div><div class="line">git remote add origin https://github.com.......//把这个网址取名为origin，</div><div class="line">git remote rm origin 删除这个远端地址</div></pre></td></tr></table></figure>
</li>
</ul>
<p>向远端提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master -u //第一次提交时,这样写。下次提交时不用输入origin master,直接写push</div></pre></td></tr></table></figure></p>
<ul>
<li>想推送到ddd分支上，那么就执行下面的操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">先切换到ddd上，git checkout ddd</div><div class="line">git add .</div><div class="line">git commit -m &apos;&apos;</div><div class="line">git push origin ddd</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="发布自己的博客"><a href="#发布自己的博客" class="headerlink" title="发布自己的博客"></a>发布自己的博客</h3><ul>
<li><p>发布hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure>
</li>
<li><p>生成blog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init</div></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure>
</li>
<li><p>文章放在_posts下（必须是md文件）</p>
</li>
<li><p>仓库名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github名.github.io</div></pre></td></tr></table></figure>
</li>
<li><p>发布到git上需要下载一个插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
</li>
<li><p>配置_config</p>
</li>
</ul>
<hr>
<p>.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://username:password@github.com/Liu-10004/Liu-10004.github.io.git</div><div class="line">  branch: master</div><div class="line">  message: push</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这时，server在启动中，可以访问localhost:4000在本地查看自己的博客<br>如果想生成一个网址，让别人访问，就需要继续进行下面的操作</p>
</blockquote>
<ul>
<li><p>提交到git上去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g  //相当于执行了推送到缓存区和版本库的操作</div></pre></td></tr></table></figure>
</li>
<li><p>发布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure>
</li>
<li><p>访问网址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Liu-10004.github.io</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="发布静态页"><a href="#发布静态页" class="headerlink" title="发布静态页"></a>发布静态页</h3><ul>
<li>发布的静态页必须在gh-pages分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b gh-pages //（分支gh-pages）固定的写法</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">添加仓库名</div><div class="line">git add .</div><div class="line">git commit -m &apos;&apos;</div><div class="line">git push origin gh-pages</div><div class="line">通过生成的地址来查看静态页</div></pre></td></tr></table></figure>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>讲师创建仓库，<br>组长fork，克隆下来，添加一个文件，再上传到git ，最后请求合并</p>
<p>组长在settings里，给组员开通权限，组员和组长就共享了同一个仓库，组员把文件克隆下来，修改后再推送到这个仓库里</p>
<ul>
<li>组长拉到自己仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone 仓库地址</div></pre></td></tr></table></figure>
</li>
</ul>
<p>组长接下来组长的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add teacher https://github.com.......//把这个网址取名为origin</div></pre></td></tr></table></figure></p>
]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[template]]></title>
        <url>http://yoursite.com/2017/06/04/template/</url>
        <content type="html"><![CDATA[<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>  1)有效数字的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg=/^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;</div></pre></td></tr></table></figure></p>
<p>  2)邮箱的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;</div></pre></td></tr></table></figure></p>
<p>  3)电话的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg = /^1\d&#123;10&#125;$/;</div></pre></td></tr></table></figure></p>
<p>  4)年龄在18-65之间的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg = /^((18|19)|([2-5]\d)|(6[0-5]))$/;</div></pre></td></tr></table></figure></p>
<p>  5)中文姓名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg = /^[\u4e00-\u9fa5]&#123;2,4&#125;$/;</div></pre></td></tr></table></figure></p>
<p>  6)身份证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  var reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(?:\d&#123;2&#125;)(\d)(?:\d|X)$/;</div><div class="line">  //-&gt; 130828(省市县) 1990(年) 12(月) 04(日) 06 1(奇数是男偶数是女) 7(数字或者X)</div><div class="line">```  </div><div class="line">  7）去首尾空格</div></pre></td></tr></table></figure></p>
<pre><code>String.prototype.myTrim=function (){
    return this.replace(/(^\s+)|(\s+$)/g, &apos;&apos;)
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">8）仿node中的query</div></pre></td></tr></table></figure>
<p>String.prototype.queryUrl=function () {<br>            var reg = /([^&amp;?#]+)=([^&amp;?=#])/g;<br>            var obj = {};<br>            this.replace(reg, function () {<br>                return obj[arguments[1]] = arguments[2];<br>            })<br>            return obj;<br>        }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">   9）验证请求地址后缀名</div><div class="line">```   </div><div class="line"> var reg = /\.([0-9a-zA-Z]+)/i;</div><div class="line">``` </div><div class="line">  10）时间格式化</div><div class="line">``` </div><div class="line">	String.prototype.myFormatTime = function (template) &#123;</div><div class="line">    		template = template || &apos;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&apos;;</div><div class="line">    		let ary = this.match(/\d+/g);</div><div class="line">    		template = template.replace(/\&#123;(\d)\&#125;/g, function () &#123;</div><div class="line">        		let index = arguments[1],</div><div class="line">            		num = ary[index] || &apos;00&apos;;</div><div class="line">        		num.length &lt; 2 ? num = &apos;0&apos; + num : null;</div><div class="line">        		return num;</div><div class="line">    		&#125;);</div><div class="line">    	return template;</div><div class="line">	&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="任意数求和"><a href="#任意数求和" class="headerlink" title="任意数求和"></a>任意数求和</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function sum() &#123;</div><div class="line">    var total = null;</div><div class="line">    //-&gt;arguments.forEach 不能直接调取数组的方法</div><div class="line">    // Array.prototype.forEach.call(arguments, function (item, index) &#123;</div><div class="line">    //     item = Number(item);</div><div class="line">    //     !isNaN(item) ? total += item : null;</div><div class="line">    // &#125;);</div><div class="line"></div><div class="line">    //-&gt;周氏继承法,让ARG指向Array.prototype,这样ARG就可以调取数组中的方法了(__proto__在IE下不兼容,但是在NODE环境下可以放心使用)</div><div class="line">    arguments.__proto__ = Array.prototype;</div><div class="line">    arguments.forEach(function (item, index) &#123;</div><div class="line">        item = Number(item);</div><div class="line">        !isNaN(item) ? total += item : null;</div><div class="line">    &#125;);</div><div class="line">    return total;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最大值最小值"><a href="#最大值最小值" class="headerlink" title="最大值最小值"></a>最大值最小值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[1,7,9,23,12,22,1];</div><div class="line">Math.max.apply(null,ary)</div><div class="line">Math.min.apply(null,ary)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ary.sort(function (a,b)&#123;</div><div class="line">        return a-b;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var max=ary[0];</div><div class="line"> var min=ary[0];</div><div class="line"> for(var i=0;i&lt;ary.length;i++)&#123;</div><div class="line">     if(ary[i]&gt;=max)&#123;max=ary[i]&#125;</div><div class="line">     if(ary[i]&lt;=min)&#123;min=ary[i]&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="类数组转数组"><a href="#类数组转数组" class="headerlink" title="类数组转数组"></a>类数组转数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;form name=&quot;myform&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</div><div class="line">    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;</div><div class="line">    &lt;textarea name=&quot;area&quot;&gt;&lt;/textarea&gt;</div><div class="line">    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    function serializeForm(form) &#123;</div><div class="line">        var result = [];</div><div class="line">        for(var i = 0; i&lt;form.length;i++)&#123;</div><div class="line">            var element = form.elements[i];</div><div class="line">            switch (element.type)&#123;</div><div class="line">                case &apos;text&apos;:</div><div class="line">                case &apos;textarea&apos;:</div><div class="line">                case &apos;hidden&apos;:</div><div class="line">                case &apos;password&apos;:                   result.push(encodeURIComponent(element.name)+&apos;=&apos;+encodeURIComponent(element.value))</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result.join(&apos;&amp;&apos;);</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>###数组扁平化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var data = [1,[2,[3,4],5,6]];</div><div class="line">    function flat(data,result) &#123;</div><div class="line">        for(var i = 0; i&lt;data.length;i++)&#123;</div><div class="line">            var temp = data[i];</div><div class="line">            if(typeof temp == &apos;number&apos;)&#123;</div><div class="line">                result.push(temp);</div><div class="line">            &#125;else&#123;</div><div class="line">                flat(temp,result)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var result = [];</div><div class="line">    flat(data,result);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var str=data.toString();</div><div class="line">var ary=str.split(&apos;,&apos;);		//[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;]</div><div class="line">var ary1=[];</div><div class="line">for(var i=0;i&lt;ary.length;i++)&#123;</div><div class="line">ary1.push(Number(ary[i]));</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[正则]]></title>
        <url>http://yoursite.com/2017/06/04/%E6%AD%A3%E5%88%99/</url>
        <content type="html"><![CDATA[<h3 id="定义：用来处理字符串的规则"><a href="#定义：用来处理字符串的规则" class="headerlink" title="定义：用来处理字符串的规则"></a>定义：用来处理<strong>字符串</strong>的规则</h3><h4 id="1、匹配：判断一个字符串是否符合我们制定的规则-gt-test-reg-test-str"><a href="#1、匹配：判断一个字符串是否符合我们制定的规则-gt-test-reg-test-str" class="headerlink" title="1、匹配：判断一个字符串是否符合我们制定的规则-&gt;test:reg.test(str)"></a>1、匹配：判断一个字符串是否符合我们制定的规则-&gt;test:reg.test(str)</h4><h4 id="2、捕获：-把字符串中符合我们正则规则的内容捕获到-gt-reg-exec-str"><a href="#2、捕获：-把字符串中符合我们正则规则的内容捕获到-gt-reg-exec-str" class="headerlink" title="2、捕获： 把字符串中符合我们正则规则的内容捕获到-&gt;reg.exec(str)"></a>2、捕获： 把字符串中符合我们正则规则的内容捕获到-&gt;reg.exec(str)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg=/\d/;</div><div class="line">console.log(reg.exec(&apos;1&apos;));//[&apos;1&apos;,index:0,input:&apos;1&apos;];</div></pre></td></tr></table></figure>
<h3 id="创建正则的两种方式："><a href="#创建正则的两种方式：" class="headerlink" title="创建正则的两种方式："></a>创建正则的两种方式：</h3><ul>
<li><p>1、字面量创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg=/\d/;</div></pre></td></tr></table></figure>
</li>
<li><p>2、实例创建方式：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg=new RegExp(&apos;&apos;);</div></pre></td></tr></table></figure>
<blockquote>
<p>　两种创建方式的区别？</p>
<ul>
<li>１、字面量方式中出现的一切都是元字符，所以不能进行变量值的拼接，而实例创建的方式是可以的</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg=/^\d+&quot;+name+&quot;\d+$/g;</div><div class="line">reg.test(&apos;2000&quot;&quot;nameeee&quot;2001&apos;);//true;</div></pre></td></tr></table></figure>
<p>-</p>
<h4 id="每个正则表达式都是由元字符和修饰符组成的（在-之间有意义的一些字符）"><a href="#每个正则表达式都是由元字符和修饰符组成的（在-之间有意义的一些字符）" class="headerlink" title="每个正则表达式都是由元字符和修饰符组成的（在//之间有意义的一些字符）"></a>每个正则表达式都是由元字符和修饰符组成的（在//之间有意义的一些字符）</h4><p>1、具有特殊意义的元字符</p>
<ul>
<li>\ :转义字符，转义后面字符所代表的含义</li>
<li>^:以某一个元字符开始</li>
<li>$:以某一个元字符结尾</li>
<li>点.：代表处理\n以外的任意字符</li>
<li><p>\n:匹配一个换行符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var reg=/^0.2$/;//以0开头，以2结尾，中间可以是除了\n的任意字符</div><div class="line">reg.test(&apos;0-2&apos;);//true</div><div class="line">reg.test(&apos;0.2&apos;);//true</div></pre></td></tr></table></figure>
</li>
<li><p>():分组 -&gt;把一个大正则划分成几个小正则</p>
</li>
<li>\w:数字、字母、下滑下中的任意一个字符-&gt; [0-9a-zA-Z_]</li>
<li>\s:匹配一个空白字符 空格、一个指标符、换页符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg=/^(\d+)abcd(\d+)$/;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- x|y:x或者y中的一个字符</div><div class="line">- [xyz]:x y z中的其中一个字符</div><div class="line">- [^xyz]:除了xyz中的任意一个字符</div><div class="line">- [a-z]:a-z之间的任何一个字符</div><div class="line">- [^a-z]:除了a-z之间的任何一个字符</div><div class="line">- \d:一个0-9之间的数字  \D:除了0-9之间的数字以外的任何字符</div><div class="line">- \b:一个边界符 &apos;a1 b2 c3&apos;</div><div class="line">&gt; []中的字符不需要转义，但是\w除外，[]中不能出现两位数</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">年龄介于18~65之间；</div><div class="line">var reg=/[18-65]/;//这样写肯定不行</div><div class="line">var reg1=/^1[8-9]|[2-5][0-9]|6[0-5]/;</div><div class="line">reg1.test(&apos;18&apos;);//true</div></pre></td></tr></table></figure>
<p>2、代表出现次数的量词元字符</p>
<ul>
<li>*：出现零次或多次</li>
<li>+：出现一次到多次</li>
<li>？：出现零次或者一次</li>
<li>{n}：正好出现n次</li>
<li>{n,}:出现n到多次</li>
<li>{n,m}出现n到m次<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">邮箱验证</div><div class="line">左边：数字、字母、下划线、.、-</div><div class="line">var reg=/^[\w.-]+@[0-9a-zA-Z]+(\.[a-zA-Z]&#123;2,4&#125;)&#123;1,2&#125;$/;</div><div class="line">reg.test(&apos;liubingqun163@163.com&apos;);//true;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>3、分组的作用一：改变x|y的默认的优先级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var reg=/^18|19$/;</div><div class="line">reg.test(&apos;189&apos;);//true;</div><div class="line">var reg1=/^(18|19)$/;</div><div class="line">reg1.test(&apos;189&apos;);//false;</div></pre></td></tr></table></figure></p>
<h3 id="exec正则的捕获"><a href="#exec正则的捕获" class="headerlink" title="exec正则的捕获"></a>exec正则的捕获</h3><p>捕获的内容格式：</p>
<h5 id="1、捕获到的内容是一个数组"><a href="#1、捕获到的内容是一个数组" class="headerlink" title="1、捕获到的内容是一个数组"></a>1、捕获到的内容是一个数组</h5><ul>
<li>数组中的第一项是当前大正则捕获的内容</li>
<li>index ：捕获内容在字符串中开始的索引位置</li>
<li>input：捕获的原始字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var reg=/\d+/;</div><div class="line">var str=&apos;luck2017byby2016&apos;;</div><div class="line">var res=reg.exec(str);</div><div class="line">console.log(res);</div><div class="line">//[&apos;2017&apos;,index:4,input:&apos;luck2017byby2016&apos;];</div><div class="line">res=reg.exec(str);</div><div class="line">console.log(res);</div><div class="line">//[&apos;2017&apos;,index:4,input:&apos;luck2017byby2016&apos;];</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>为什么会出现上面的情况呢？因为正则的懒惰型</p>
<h5 id="2、正则捕获的特点："><a href="#2、正则捕获的特点：" class="headerlink" title="2、正则捕获的特点："></a>2、正则捕获的特点：</h5><ul>
<li>懒惰型-&gt;每一次执行exec只捕获第一个匹配的内容，不进行任何处理的情况下，在执行多次捕获，捕获的还是第一个匹配的内容</li>
<li>lastIndex：是正则每一次捕获在字符串中开始查找的位置，默认值是0；它跟懒惰型有直接关系</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var reg=/\d+/;</div><div class="line">var str=&apos;luck2017byby2016&apos;;</div><div class="line">var res=reg.exec(str);</div><div class="line">console.log(reg.lastIndex); //8</div><div class="line">console.log(res);</div><div class="line">//[&apos;2017&apos;,index:4,input:&apos;luck2017byby2016&apos;];</div><div class="line">res=reg.exec(str);</div><div class="line">console.log(reg.lastIndex); //8</div><div class="line">console.log(res);</div><div class="line">//[&apos;2017&apos;,index:4,input:&apos;luck2017byby2016&apos;];</div></pre></td></tr></table></figure>
<blockquote>
<p>我们能看出来lastIndex每次都一样，那么该怎么处理呢<br>在正则后面加上字符g</p>
</blockquote>
<p>修饰符：g(全局)、i（ignoreCase忽略大小写）、m（multiline多行匹配）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var reg=/\d+/g;</div><div class="line">var str=&apos;luck2017byby2016&apos;;</div><div class="line">var res=reg.exec(str);</div><div class="line">console.log(reg.lastIndex); //8</div><div class="line">console.log(res);</div><div class="line">//[&apos;2017&apos;,index:4,input:&apos;luck2017byby2016&apos;];</div><div class="line">res=reg.exec(str);</div><div class="line">console.log(reg.lastIndex); //16</div><div class="line">console.log(res);</div><div class="line">//[&quot;2016&quot;, index: 12, input: &quot;luck2017byby2016&quot;];</div></pre></td></tr></table></figure></p>
<blockquote>
<p>原理：加了全局修饰符g，正则每一次捕获结束后，我们的lastIndex的值都变为了最新的值，下一次捕获从最新的位置开始查找，这样就可以把所有需要捕获的内容都获取到了</p>
<h5 id="3、自己编写程序获取正则获取的所有的内容（一定不能忘记加g）"><a href="#3、自己编写程序获取正则获取的所有的内容（一定不能忘记加g）" class="headerlink" title="3、自己编写程序获取正则获取的所有的内容（一定不能忘记加g）"></a>3、自己编写程序获取正则获取的所有的内容（一定不能忘记加g）</h5></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var reg=/\d+/g;</div><div class="line">var str=&apos;luck2017byby2016&apos;;</div><div class="line">var ary=[];</div><div class="line">var res=reg.exec(str);</div><div class="line">while(res)&#123;</div><div class="line">    ary.push(res[0]);</div><div class="line">    res=reg.exec(str);</div><div class="line">&#125;</div><div class="line">console.log(ary);//[&apos;2016&apos;,&apos;2017&apos;]</div></pre></td></tr></table></figure>
<h5 id="4、正则的贪婪性"><a href="#4、正则的贪婪性" class="headerlink" title="4、正则的贪婪性"></a>4、正则的贪婪性</h5><ul>
<li>如果我只想捕获到2017中的2，那该怎么办？</li>
<li>正则在匹配的时候，是按照最长的匹配结果来匹配的，这就是它的贪婪性。例如：2和2017都复合上面demo的reg，但是捕获的是2017,。</li>
<li>解决正则贪婪性的方法和解决懒惰型的方法一样简单，在==量词元字符==后面加一个？即可，问号代表了取消捕获时候的贪婪性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var reg=/\d+?/g;</div><div class="line">var str=&apos;luck2017byby2016&apos;;</div><div class="line">var ary=[];</div><div class="line">var res=reg.exec(str);</div><div class="line">while(res)&#123;</div><div class="line">    ary.push(res[0]);</div><div class="line">    res=reg.exec(str);</div><div class="line">&#125;</div><div class="line">console.log(ary);</div><div class="line">//[&quot;2&quot;, &quot;0&quot;, &quot;1&quot;, &quot;7&quot;, &quot;2&quot;, &quot;0&quot;, &quot;1&quot;, &quot;6&quot;]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="字符串中的match方法-gt-把所有和正则匹配的字符都获取到"><a href="#字符串中的match方法-gt-把所有和正则匹配的字符都获取到" class="headerlink" title="字符串中的match方法-&gt;把所有和正则匹配的字符都获取到"></a>字符串中的match方法-&gt;把所有和正则匹配的字符都获取到</h3><p>看下面的match方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var reg=/\d+/g;</div><div class="line">var str=&apos;luck2017byby2016&apos;;</div><div class="line">var ary=str.match(reg)</div><div class="line">console.log(ary);//[&quot;2017&quot;, &quot;2016&quot;]</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var reg=/\d+?/g;</div><div class="line">var str=&apos;luck2017byby2016&apos;;</div><div class="line">var ary=str.match(reg)</div><div class="line">console.log(ary);//[&quot;2&quot;, &quot;0&quot;, &quot;1&quot;, &quot;7&quot;, &quot;2&quot;, &quot;0&quot;, &quot;1&quot;, &quot;6&quot;]</div></pre></td></tr></table></figure>
<blockquote>
<p>从事例中能看出match比exec简洁很多，但是match中存在一些自己处理不了的问题</p>
</blockquote>
<p>在分组捕获时，match只能捕获到大正则匹配的内容，无法捕获到小正则的内容，下面学习分组</p>
<h4 id="正则分组"><a href="#正则分组" class="headerlink" title="正则分组"></a>正则分组</h4><ul>
<li>1、改变优先级</li>
<li><p>2、分组引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var reg=/^(\w)\1(\w)\2$/;</div><div class="line">console.log(reg.test(&apos;aaff&apos;));//true</div><div class="line">console.log(reg.test(&apos;a0f_&apos;));//false</div><div class="line">\1代表和第一个分组出现一模一样的内容；\2代表和第二个分组出现一模一样的内容</div></pre></td></tr></table></figure>
</li>
<li><p>3、分组捕获 -&gt;正则在捕获的时候，不仅仅把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var reg=/^(\d&#123;2&#125;)(\d&#123;4&#125;)$/;</div><div class="line">var str=&apos;122344&apos;;</div><div class="line">console.log(reg.exec(str));</div><div class="line">//[&quot;122344&quot;, &quot;12&quot;, &quot;2344&quot;, index: 0, input: &quot;122344&quot;]</div><div class="line">数组中的第一项：大正则捕获到的内容</div><div class="line">        第二项：第一个小正捕获到的内容</div><div class="line">        第三项：第二个小正则捕获到的内容</div><div class="line">        第四项：捕获的开始项</div><div class="line">        第五项：原始的输入</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果正则中出现了 ?: ,代表只匹配，不捕获<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var reg=/^(\d&#123;2&#125;)(?:\d&#123;4&#125;)$/;</div><div class="line">var str=&apos;122344&apos;;</div><div class="line">console.log(reg.exec(str));</div><div class="line">//[&quot;122344&quot;, &quot;12&quot;, index: 0, input: &quot;122344&quot;]</div></pre></td></tr></table></figure></p>
<p>下面我们再讲讲match的梗；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var reg=/(\d&#123;2&#125;)(\d&#123;4&#125;)$/;</div><div class="line">var str=&apos;122344&apos;;</div><div class="line">console.log(str.match(reg));</div><div class="line">//[&quot;122344&quot;, &quot;12&quot;, &quot;2344&quot;, index: 0, input: &quot;122344&quot;]</div></pre></td></tr></table></figure></p>
<p>what?竟然和exec一样的，到底区别在哪？来看下面的代码,原因是只捕获一次就捕获到了所有的内容，那么match和exec作用一样，那什么时候作用不一样呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var reg=/abc(\d+)/g;</div><div class="line">var str=&apos;abc123abc456abc789&apos;</div><div class="line">console.log(reg.exec(str));//[&quot;abc123&quot;, &quot;123&quot;, index: 0, input: &quot;abc123abc456abc789&quot;]</div><div class="line">console.log(reg.exec(str))//[&quot;abc456&quot;, &quot;456&quot;, index: 6, input: &quot;abc123abc456abc789&quot;]</div><div class="line">console.log(reg.exec(str));//[&quot;abc456&quot;, &quot;456&quot;, index: 6, input: &quot;abc123abc456abc789&quot;]</div><div class="line">console.log(str.match(reg));//[&quot;abc123&quot;, &quot;abc456&quot;, &quot;abc789&quot;]</div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们能明显的看到在全局g下，match捕获到的是大正则匹配的内容，没有小分组。如果没有全局g,再看看代码的执行情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var reg=/abc(\d+)/g;</div><div class="line">var str=&apos;abc123abc456abc789&apos;</div><div class="line">console.log(reg.exec(str));//[&quot;abc123&quot;, &quot;123&quot;, index: 0, input: &quot;abc123abc456abc789&quot;]</div><div class="line">console.log(reg.exec(str))//[&quot;abc123&quot;, &quot;123&quot;, index: 0, input: &quot;abc123abc456abc789&quot;]</div><div class="line">console.log(reg.exec(str));//[[&quot;abc123&quot;, &quot;123&quot;, index: 0, input: &quot;abc123abc456abc789&quot;]</div><div class="line">console.log(str.match(reg));//[&quot;abc123&quot;, &quot;123&quot;, index: 0, input: &quot;abc123abc456abc789&quot;]</div></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>如果我先替换掉字符串时，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str=&apos;ab12ab23&apos;;</div><div class="line">str=str.replace(&apos;ab&apos;,&apos;abcd&apos;);</div><div class="line">console.log(str);//&apos;abcd12ab23&apos;</div></pre></td></tr></table></figure></p>
<p>我们看到了replace只替换了一次，如果用正则替换呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str=&apos;ab12ab23&apos;;</div><div class="line">str=str.replace(/ab/g,&apos;abcd&apos;);</div><div class="line">console.log(str);//&apos;abcd12abcd23&apos;</div></pre></td></tr></table></figure></p>
<p>功能已经实现，但是怎么实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var str=&apos;ab12ab23&apos;;</div><div class="line">str=str.replace(/ab/g,function()&#123;</div><div class="line">    console.log(arguments);</div><div class="line">    return &apos;abcd&apos;</div><div class="line">&#125;)</div><div class="line">str;//&apos;abcd12abcd23&apos;</div><div class="line">arguments;//[&quot;ab&quot;, 0, &quot;ab12ab23&quot;]</div><div class="line">          //[&quot;ab&quot;, 4, &quot;ab12ab23&quot;]</div></pre></td></tr></table></figure>
<ul>
<li>1、首先我们和exec捕获一样，把所有和我们正则匹配的都捕获到，让后把捕获的内容替换成我们需要替换的新内容</li>
<li>2、每次执行匿名函数，里面传递的参数值arguments和我们自己通过exec捕获到的结果非常类似（即使正则有分组，我们同样可以通过arguments获取到分组捕获的内容）</li>
<li>3、return  返回的结果，相当于把当前这一次==大正则==捕获的内容替换掉</li>
</ul>
<p>如果正则中存在小分组时，结果怎样呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var str=&apos;ab12ab23&apos;;</div><div class="line">str=str.replace(/a(b)/g,function()&#123;</div><div class="line">    console.log(arguments);</div><div class="line">    return &apos;abcd&apos;</div><div class="line">&#125;)</div><div class="line">str;//&apos;abcd12abcd23&apos;</div><div class="line">arguments;//[&quot;ab&quot;, &quot;b&quot;, 0, &quot;ab12ab23&quot;]</div><div class="line">          //[&quot;ab&quot;, &quot;b&quot;, 4, &quot;ab12ab23&quot;]</div><div class="line">str没有变化， 只是arguments发生了变化。</div></pre></td></tr></table></figure></p>
]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[数组中常用的方法]]></title>
        <url>http://yoursite.com/2017/06/04/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
        <content type="html"><![CDATA[<ul>
<li><p>1、push</p>
<blockquote>
<p>作用：像数组的末尾添加一项或多项元素<br>参数：要添加的项<br>返回值：新数组的长度<br>是否改变原数组：改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">var res = ary.push(&apos;d&apos;,&apos;e&apos;); </div><div class="line">console.log(ary);  // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</div><div class="line">console.log(res);  // 5</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>2、pop</p>
<blockquote>
<p>作用：删除数组的最后一项<br>参数：无<br>返回值：被删除的项<br>是否改变原数组：改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;];</div><div class="line">var res = ary.pop();</div><div class="line">console.log(ary);  // [&apos;1&apos;,&apos;2&apos;]</div><div class="line">console.log(res);  // 3</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>3、shift</p>
<blockquote>
<p>作用：删除数组的首项<br>参数：无<br>返回值：被删除的项<br>是否改变原数组：改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">var res = ary.shift();</div><div class="line">console.log(ary);  // [&apos;b&apos;,&apos;c&apos;]</div><div class="line">console.log(res);  // a</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>4、unshift</p>
<blockquote>
<p>作用：向数组的开头添加一或多项<br>参数：要添加的项，多项用’,’隔开<br>返回值：新数组的长度<br>是否改变原数组：改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">var res = ary.unshift(&apos;d&apos;,&apos;e&apos;);</div><div class="line">console.log(ary);  // [&quot;d&quot;, &quot;e&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line">console.log(res);  // 5</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>5 、splice</p>
<blockquote>
<p>作用：增删改<br>参数：ary.splice(index,howmany,item1,…..,itemX)<br>返回值：删除的项<br>是否改变原数组：改变</p>
</blockquote>
</li>
</ul>
<p>增加的功能<br>ary.splice(n,0,x，……,y);<br>从数组的索引n开始，删除0项,在索引n的前边增加新的项，第三个参数开始都是用来填补删除的项目位置的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5];</div><div class="line">var res = ary.splice(1,0,6,7);</div><div class="line">console.log(ary);  // [1, 6, 7, 2, 3, 4, 5]</div><div class="line">console.log(res);  // [] 删除0项，返回一个空数组</div></pre></td></tr></table></figure></p>
<p>删除的功能<br>ary.splice(n,m);<br>从数组的索引n开始，删除m项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5];</div><div class="line">var res = ary.splice(1,2);</div><div class="line">console.log(ary);  // [1，4，5]</div><div class="line">console.log(res);  // [2，3]</div></pre></td></tr></table></figure></p>
<p>修改的功能<br>ary.splice(n,m,x);<br>从数组的索引n开始，删除m项，把x添加到索引n前边<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5];</div><div class="line">var res = ary.splice(1,2,6,7);</div><div class="line">console.log(ary);  // [1, 6, 7, 4, 5]</div><div class="line">console.log(res);  // [2，3]</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">模拟push(尾部添加)  和push二者返回值不同</div><div class="line">ary.splice(ary.length,0,新的项) //因为splice是在索引前添加，所以第一个参数为ary.length</div><div class="line">//模拟 pop(尾部删除)</div><div class="line">ary.splice(arr.length-1,1);</div><div class="line">//模拟 shift(首项删除)</div><div class="line">ary.splice(0,1)</div><div class="line">//模拟 unshift(首项添加) 和unshilft二者返回值不同</div><div class="line">ary.splice(0,0,新的项)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ary.splice(n)  // 表示从索引n开始删除到末尾</div><div class="line">ary.splice(0)  // 删除整个数组 有克隆数组的效果，利用返回值</div></pre></td></tr></table></figure>
<ul>
<li><p>6 、slice</p>
<blockquote>
<p>作用：截取数组(复制数组)<br>参数：array.slice(start, end)<br>返回值：返回一个新数组<br>是否改变原数组：不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5];</div><div class="line">var res = ary.slice(1,3);</div><div class="line">var res2 = ary.slice(-3,-1)</div><div class="line">console.log(ary);  // [1,2,3,4,5]</div><div class="line">console.log(res);  // [2,3]</div><div class="line">console.log(res2)  //[3,4] slice支持负参数，从最后一项开始算起，-1为最后一项，-2为倒数第二项</div><div class="line"></div><div class="line">slice(n) //从索引n开始复制到最后一项</div><div class="line">slice()、 slice(0)  //复制整个数组</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>7、join</p>
<blockquote>
<p>作用：用指定的分隔符将数组每一项拼接为字符串<br>参数：指定的分隔符,如果省略该参数，则使用逗号作为分隔符<br>返回值：拼接好的字符串<br>是否改变原数组：不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5];</div><div class="line">var res = ary.join(&apos;-&apos;);</div><div class="line">console.log(ary);  // [1, 2, 3, 4, 5]</div><div class="line">console.log(res);  // 1-2-3-4-5</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>8、concat</p>
<blockquote>
<p>作用：用于连接两个或多个数组<br>参数：参数可以是具体的值，也可以是数组对象。可以是任意多个<br>返回值：返回连接后的新数组<br>是否改变原数组：不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5];</div><div class="line">var res = ary.concat(6,7);</div><div class="line">var res2 = ary.concat(6,[7,8]);</div><div class="line">var res3 = ary.concat(6,[7,[8,9]]);</div><div class="line">var res4 = ary.concat();</div><div class="line">console.log(ary);  // [1, 2, 3, 4, 5]</div><div class="line">console.log(res);  // [1, 2, 3, 4, 5, 6, 7]</div><div class="line">console.log(res2);  //[1, 2, 3, 4, 5, 6, 7, 8]</div><div class="line">console.log(res3)  // [1, 2, 3, 4, 5, 6, 7, [8,9]]  concat() 如果操作的参数是数组，那么添加的是数组中的元素，而不是数组。 如果是二维(或以上)数组，concat只能&apos;拆开&apos;一层数组</div><div class="line">console.log(res4) // [1, 2, 3, 4, 5]  如果concat()没有参数或者参数是空数组也可以达到克隆数组的目的</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>9、sort</p>
<blockquote>
<p>作用：对数组的元素进行排序<br>参数：可选(函数) 规定排序规则 默认排序顺序为按字母升序<br>返回值：排好序的原数组<br>是否改变原数组：改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var ary = [1,5,7,9,12,24,56,87,92];</div><div class="line">var ary2 = [1,5,7,9,12,24,56,87,92];</div><div class="line">var ary3 = [1,5,7,9,12,24,56,87,92];</div><div class="line">var res = ary.sort();</div><div class="line">var res2 = ary2.sort(function(a,b)&#123;</div><div class="line">    return a-b;</div><div class="line">&#125;)</div><div class="line">var res3 = ary3.sort(function(a,b)&#123;</div><div class="line">    return b-a;</div><div class="line">&#125;)</div><div class="line">// sort的参数函数总的形参a,b就是数组排序时候的相邻比较的两项</div><div class="line">console.log(res);  // [1, 12, 24, 5, 56, 7, 87, 9, 92]</div><div class="line">console.log(res2); // [1, 5, 7, 9, 12, 24, 56, 87, 92]</div><div class="line">console.log(res3); // [92, 87, 56, 24, 12, 9, 7, 5, 1]</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>10、reverse</p>
<blockquote>
<p>作用：倒序数组<br>参数：无<br>返回值：倒序后的原数组<br>是否改变原数组：改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5];</div><div class="line">var res = ary.reverse();</div><div class="line">console.log(ary);  // [5, 4, 3, 2, 1]</div><div class="line">console.log(res);  // [5, 4, 3, 2, 1]</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>11 、indexOf</p>
<blockquote>
<p>作用：查找指定元素的位置<br>参数：array.indexOf(item,start) item:查找的元素 start:字符串中开始检索的位置<br>返回值：返回第一次查到的索引，未找到返回-1<br>是否改变原数组： 不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5]</div><div class="line">var res = ary.indexOf(3);</div><div class="line">console.log(ary);  // [1,2,3,4,5]</div><div class="line">console.log(res);  // 2</div><div class="line">var ary = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;c&apos;];</div><div class="line">var res = ary.indexOf(&apos;c&apos;,3);</div><div class="line">console.log(res) // 4</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>12、lastIndexOf</p>
<blockquote>
<p>作用：查找指定元素最后出现的位置<br>参数：array.indexOf(item,start) item:查找的元素 start:字符串中开始检索的位置<br>返回值：返回查到的元素的索引，未找到返回-1<br>是否改变原数组：不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var ary = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;c&apos;];</div><div class="line">var res = ary.lastIndexOf(&apos;c&apos;,3);</div><div class="line">var res2 = ary.lastIndexOf(&apos;c&apos;,1);</div><div class="line">console.log(res); // 2</div><div class="line">console.log(res2); // -1</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>13 、forEach</p>
<blockquote>
<p>作用：循环遍历数组每一项<br>参数：函数 ary.forEach(function(item,index,ary){}) item:每一项 index:索引 ary:当前数组<br>返回值：无<br>是否改变原数组： 不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var ary = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</div><div class="line">var res = ary.forEach(function(item,index,ary)&#123;</div><div class="line">    console.log(item,index,ary);</div><div class="line">/*  a 0 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line">    b 1 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line">    c 2 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line">*/  </div><div class="line">    return item;</div><div class="line">&#125;)</div><div class="line">console.log(res)  // undefined  无返回值</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>14 、map</p>
<blockquote>
<p>作用：数组中的元素为原始数组元素调用函数处理后的值<br>参数：函数 ary.map(function(item,index,ary){}) item:每一项 index:索引 ary:当前数组<br>返回值：新数组<br>是否改变原数组：不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ary = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</div><div class="line">var res = ary.map(function(item,index,ary)&#123;</div><div class="line">    if(item==&apos;a&apos;)&#123;return &apos;d&apos;&#125;;</div><div class="line">    return item;</div><div class="line">&#125;)</div><div class="line">console.log(res)  // [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;]</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>15、filter</p>
<blockquote>
<p>作用：创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br>参数：函数 ary.filter(function(item,index,ary){}) item:每一项 index:索引 ary:当前数组<br>返回值：新数组<br>是否改变原数组：不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5,6]</div><div class="line">var res = ary.filter(function(item)&#123;</div><div class="line">    return item&lt;3;</div><div class="line">&#125;)</div><div class="line">console.log(res)  // [1,2]</div></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>16、every<blockquote>
<p>作用：检测数组所有元素是否都符合指定条件<br>参数：函数 ary.every(function(item,index,ary){}) item:每一项 index:索引 ary:当前数组<br>返回值：布尔值<br>是否改变原数组： 不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5,6]</div><div class="line">var res = ary.every(function(item)&#123;</div><div class="line">    return item&lt;3;</div><div class="line">&#125;)</div><div class="line">var res2 = ary.every(function(item)&#123;</div><div class="line">    return item&lt;7;</div><div class="line">&#125;)</div><div class="line">console.log(res)  // false;</div><div class="line">console.log(res2)  // true;</div><div class="line">1 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</div><div class="line">2 如果所有元素都满足条件，则返回 true。</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>17、some</p>
<blockquote>
<p>作用：检测数组中的元素是否满足指定条件<br>参数：函数 ary.some(function(item,index,ary){}) item:每一项 index:索引 ary:当前数组<br>返回值：布尔值<br>是否改变原数组：不改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3,4,5,6]</div><div class="line">var res = ary.some(function(item)&#123;</div><div class="line">    return item&lt;3;</div><div class="line">&#125;)</div><div class="line">console.log(res)  // true;</div><div class="line">1 如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。</div><div class="line">2 如果没有满足条件的元素，则返回 false。</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>18、find</p>
<blockquote>
<p>作用：查找满足条件的一项<br>arr.find(callback[, thisArg])<br>callback 在数组每一项上执行的函数，接收 3 个参数：</p>
</blockquote>
</li>
</ul>
<p>1 、element 当前遍历到的元素。<br>2、index 当前遍历到的索引。<br>3、array 数组本身。<br>thisArg 可选，指定 callback 的 this 参数。<br>find方法对数组中的每一项元素执行一次callback 函数，直至有一个callback返回true。当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var ary=[1,2,3,5,6]</div><div class="line">var b=ary.find(function (item,index)&#123;</div><div class="line">          return item==2;</div><div class="line">                       &#125;)</div><div class="line"> console.log(b);// 2</div></pre></td></tr></table></figure></p>
]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[继承]]></title>
        <url>http://yoursite.com/2017/06/04/%E7%BB%A7%E6%89%BF/</url>
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul>
<li><p>for in循环，能列举私有的属性和所属类的原型上扩展的属性即公有的（name，age，aa)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Object.prototye.aa=function()&#123;&#125;;</div><div class="line">var obj=&#123;name:&apos;珠峰&apos;,age:7&#125;;</div><div class="line">for(var key in obj)&#123;</div><div class="line">        console.log(key); //name，age，aa</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>propertyIsEnumerable是可枚举属性，判断是否属于私有的属性</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object.prototye.aa=function()&#123;&#125;;</div><div class="line">var obj=&#123;name:&apos;珠峰&apos;,age:7&#125;;</div><div class="line">for(var key in obj)&#123;</div><div class="line">    if(obj.propertyIsEnumerable(key)) &#123;</div><div class="line">        console.log(key); //name，age</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>-也可以用下面的代码代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(obj.hasOwnProperty(key))&#123;</div><div class="line">    console.log(key);//name,age</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Object-create-proObj-创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6-8不兼容（ECMAScript5中新增特性）"><a href="#Object-create-proObj-创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6-8不兼容（ECMAScript5中新增特性）" class="headerlink" title="Object.create(proObj) 创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6~8不兼容（ECMAScript5中新增特性）"></a>Object.create(proObj) 创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6~8不兼容（ECMAScript5中新增特性）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;</div><div class="line">    constructor:Fn,</div><div class="line">    getX:function()&#123;</div><div class="line">    &#125;    </div><div class="line">&#125;</div><div class="line">function Fn()&#123;&#125;</div><div class="line">Fn.prototype=obj;</div><div class="line">var obj2=Object.create(obj)</div><div class="line">obj.getY=function()&#123;&#125;</div><div class="line">打印结果：</div><div class="line"> __proto__:Object</div><div class="line">            constructor:Fn()</div><div class="line">            getX:function()</div><div class="line">            getY:function()</div><div class="line">            __proto__:Object</div></pre></td></tr></table></figure>
<h3 id="Object-create-的模拟实现"><a href="#Object-create-的模拟实现" class="headerlink" title="Object.create()的模拟实现"></a>Object.create()的模拟实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;</div><div class="line">    getX:function()&#123;</div><div class="line">    &#125; </div><div class="line">&#125;;</div><div class="line">function objectCreate(o)&#123;</div><div class="line">    function Fn()&#123;&#125;;</div><div class="line">    Fn.prototype=o;</div><div class="line">    return new Fn;</div><div class="line">&#125;</div><div class="line">var newObj=objectCreate(obj);</div></pre></td></tr></table></figure>
<h3 id="1、原型继承"><a href="#1、原型继承" class="headerlink" title="1、原型继承"></a>1、原型继承</h3><p>B的原型=A的实例；B.prototype=new A;</p>
<ul>
<li>子类B想要继承父类A中所有的属性和方法（私有加公有），全变成B的原型（公有）；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function A()&#123;</div><div class="line">    this.x=100;</div><div class="line">&#125;</div><div class="line">A.prototype.getX=function()&#123;</div><div class="line">    console.log(this.x);</div><div class="line">&#125;;</div><div class="line">function B()&#123;</div><div class="line">    this.x=200;</div><div class="line">&#125;</div><div class="line">B.prototype=new A;</div><div class="line">var n=new B；</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>核心：原型继承并不是把父类中的属性和方法克隆一份一模一样的给B,而是让B和A之间增加了原型链的连接，以后B的实例n想要A中的getX方法，需要一级级的向上查找来使用；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n.x=1000;</div><div class="line">只是修改了n这个实例的x值，对B的其他实例没有产生作用</div></pre></td></tr></table></figure></p>
<p>子类能通过<strong>proto</strong>对父类的原型进行重写，最终导致父类的其他实例也产生了变化<br>==画图是最直观的办法==</p>
<h3 id="2、call继承"><a href="#2、call继承" class="headerlink" title="2、call继承"></a>2、call继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function A()&#123;</div><div class="line">    this.x=100;</div><div class="line">&#125;</div><div class="line">A.prototype.getX=function()[</div><div class="line">    </div><div class="line">&#125;</div><div class="line">function B()&#123;</div><div class="line">    A.call(this)</div><div class="line">&#125;</div><div class="line">var b=new B;</div></pre></td></tr></table></figure>
<p>概念：把父类私有的属性和方法克隆一份给子类私有；</p>
<h3 id="3、冒充对象继承"><a href="#3、冒充对象继承" class="headerlink" title="3、冒充对象继承"></a>3、冒充对象继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function A()&#123;</div><div class="line">    this.x=100;</div><div class="line">&#125;</div><div class="line">A.prototype.getX=function()[</div><div class="line">    </div><div class="line">&#125;</div><div class="line">function B()&#123;</div><div class="line">    var temp=new A;</div><div class="line">    for(var key in temp)&#123;</div><div class="line">        console.log(key);//x,getX</div><div class="line">        this[key]=temp[key];</div><div class="line">    &#125;</div><div class="line">    temp=null;</div><div class="line">&#125;</div><div class="line">var b=new B; // x,getX</div></pre></td></tr></table></figure>
<p>概念：把父类私有加公有克隆一份一样的，给子类私有的</p>
<h3 id="4、混合模式继承（原型继承加call继承）"><a href="#4、混合模式继承（原型继承加call继承）" class="headerlink" title="4、混合模式继承（原型继承加call继承）"></a>4、混合模式继承（原型继承加call继承）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function A()&#123;</div><div class="line">    this.x=100;</div><div class="line">&#125;</div><div class="line">A.prototype.getX=function()[</div><div class="line">    </div><div class="line">&#125;</div><div class="line">function B()&#123;</div><div class="line">    A.call(this)</div><div class="line">&#125;</div><div class="line">B.prototype=new A;</div><div class="line">B.prototype.constructor=B;</div><div class="line">var b=new B;</div></pre></td></tr></table></figure>
<p>出现了重复继承</p>
<h3 id="5、寄生组合式继承"><a href="#5、寄生组合式继承" class="headerlink" title="5、寄生组合式继承"></a>5、寄生组合式继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function A()&#123;</div><div class="line">    this.x=100;</div><div class="line">&#125;</div><div class="line">A.prototype.getX=function()[</div><div class="line">    </div><div class="line">&#125;</div><div class="line">function B()&#123;</div><div class="line">    A.call(this)</div><div class="line">&#125;</div><div class="line">//B.prototype=Object.create(A.prototype);</div><div class="line">B.prototype=objectCreate(A.prototype);</div><div class="line">B.prototype.constructor=B;</div><div class="line">var b=new B;</div><div class="line">b.getX();</div><div class="line">//处理兼容性</div><div class="line">function objectCreate(o)&#123;</div><div class="line">    funtion fn()&#123;&#125;;</div><div class="line">    fn.prototype=o;</div><div class="line">    return new fn;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="周氏继承法-中间类继承法（不兼容）"><a href="#周氏继承法-中间类继承法（不兼容）" class="headerlink" title="周氏继承法-中间类继承法（不兼容）"></a>周氏继承法-中间类继承法（不兼容）</h3><p>掐头去尾求平均值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function avgFn()&#123;</div><div class="line">    arguments.__proto__=Array.prototype;</div><div class="line">    argumets.sort(function(a,b)&#123;</div><div class="line">        return a-b;</div><div class="line">    &#125;)</div><div class="line">    arguments.pop();</div><div class="line">    arguments.shift();</div><div class="line">    return (eval(arguments.jion(&apos;+&apos;))/arguments.length).toFixed(2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="只继承公有"><a href="#只继承公有" class="headerlink" title="只继承公有"></a>只继承公有</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Child.prototype.__proto__=Parent.prototype;</div><div class="line">Child.prototype=Object.create(Parent.prototype);//ES5</div><div class="line">Object.setPrototypeOf(Child.prototype,Parent.prototype);  //ES6</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//Child.prototype=Object.create(Parent.prototype)的实现原理</div><div class="line">function create(p)&#123;</div><div class="line">    var Fn=function ()&#123;&#125;;</div><div class="line">    Fn.prototype=p;</div><div class="line">    return new Fn;</div><div class="line">&#125;</div><div class="line">Child.prototype=create(Parent.prototype);</div></pre></td></tr></table></figure>]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[PS使用]]></title>
        <url>http://yoursite.com/2017/06/04/ps%E4%BD%BF%E7%94%A8/</url>
        <content type="html"><![CDATA[<ul>
<li>缩放<ul>
<li>z，鼠标左键拖动</li>
<li>alt+鼠标滚轮</li>
<li>ctrl+’+’  或者ctrl+‘-’</li>
<li>ctrl+0  图片自适应大小</li>
<li>ctrl+1  还原图片大小</li>
</ul>
</li>
<li>移动<ul>
<li>v+鼠标左键</li>
</ul>
</li>
<li>更改单位<ul>
<li>ctrl+k  修改单位，单位与标尺，默认厘米，改为像素</li>
</ul>
</li>
<li>拖拽<ul>
<li>空格（左键不放手）或者h</li>
</ul>
</li>
<li>矩形选区<ul>
<li>m（左键不放手）</li>
<li>取消矩形选区（ctrl+d）</li>
<li>选中选区时，m快捷键可以移动选区</li>
</ul>
</li>
<li>切图<ul>
<li>快捷键c</li>
<li>shift+c 切换工具，</li>
<li>delete键取消切图区（先用切片选择工具，选择到需要删除的切片，边框变成黄色）</li>
<li>保存切片：ctrl+shift+alt+s</li>
<li>预设：JPEG高</li>
</ul>
</li>
</ul>
]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[gulp]]></title>
        <url>http://yoursite.com/2017/06/04/gulp/</url>
        <content type="html"><![CDATA[<h4 id="简介：gulp是前端开发过程中对代码构建的工具，是自动化项目的构建利器；它不仅能对网络资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，可以极大提高工作效率。"><a href="#简介：gulp是前端开发过程中对代码构建的工具，是自动化项目的构建利器；它不仅能对网络资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，可以极大提高工作效率。" class="headerlink" title="简介：gulp是前端开发过程中对代码构建的工具，是自动化项目的构建利器；它不仅能对网络资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，可以极大提高工作效率。"></a>简介：gulp是前端开发过程中对代码构建的工具，是自动化项目的构建利器；它不仅能对网络资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，可以极大提高工作效率。</h4><h4 id="gulp和grunt非常类似，但是相比于grunt的频发IO操作，gulp的流操作，能更快更便捷的完成构建工作。"><a href="#gulp和grunt非常类似，但是相比于grunt的频发IO操作，gulp的流操作，能更快更便捷的完成构建工作。" class="headerlink" title="gulp和grunt非常类似，但是相比于grunt的频发IO操作，gulp的流操作，能更快更便捷的完成构建工作。"></a>gulp和grunt非常类似，但是相比于grunt的频发IO操作，gulp的流操作，能更快更便捷的完成构建工作。</h4><h3 id="运行gulp"><a href="#运行gulp" class="headerlink" title="运行gulp"></a>运行gulp</h3><ul>
<li><p>1.在根目录下创建文件<strong>gulpfile.js</strong>,gulp执行的任务默认指定这个文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>2.创建gulp的任务</p>
<ul>
<li>参数1 ：任务的名称</li>
<li>参数2：任务的定义，是一个<strong>匿名函数</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;hello&apos;, function () &#123;</div><div class="line">   console.log(&apos;您好&apos;);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3、执行gulp任务<br>打开命令行工具，进入项目所在目录，然后输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp hello</div></pre></td></tr></table></figure>
</li>
</ul>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[21:36:34] Starting &apos;hello&apos;...</div><div class="line">    您好</div><div class="line">    [21:36:34] Finished &apos;hello&apos; after 959 μs</div></pre></td></tr></table></figure></p>
<blockquote>
<p>gulp后面跟着的是任务的名称，不输入任务名称的话会默认找到default任务，找不到会报错</p>
<h4 id="小demo"><a href="#小demo" class="headerlink" title="小demo"></a>小demo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let gulp = require(&apos;gulp&apos;);</div><div class="line">//src 获取要处理的文件,得到的是一个可读流</div><div class="line">//dest 获取一个可写流 指写是一个文件夹的名字</div><div class="line">//目标路径的生成规则是只包含通配符的部分</div><div class="line">// *表示 匹配任意字符，但不包括路径分隔符</div><div class="line">// ** 表示任意字符，也包括路径分隔符</div><div class="line">gulp.task(&apos;copy&apos;,function () &#123;</div><div class="line">  gulp.src([&apos;src/*.html&apos;,&apos;src/**/*.js&apos;]).pipe(gulp.dest(&apos;build&apos;));</div><div class="line">&#125;);</div><div class="line">gulp.task(&apos;watch&apos;,function () &#123;//</div><div class="line">  gulp.watch(&apos;src/*.html&apos;,[&apos;copy&apos;]);</div><div class="line">&#125;);</div><div class="line">gulp.task(&apos;default&apos;,[&apos;copy&apos;,&apos;watch&apos;]);</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="gulp-connect"><a href="#gulp-connect" class="headerlink" title="gulp-connect"></a>gulp-connect</h4><p>有时候我们们需要把文件放到本地服务器上去预览，gulp-connect可以帮我们创建一个本地服务器去运行我们的项目<br>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install gulp-connect --save-dev</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;);</div><div class="line">var connect = require(&apos;gulp-connect&apos;);</div><div class="line">gulp.task(&apos;serve&apos;,function () &#123;</div><div class="line">  connect.server(&#123;</div><div class="line">    port:8080,</div><div class="line">    root:&apos;./build&apos;,</div><div class="line">    livereload:true//浏览器自动刷新</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line">gulp.task(&apos;default&apos;,[&apos;server&apos;]);</div></pre></td></tr></table></figure>
]]></content>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[Hello World]]></title>
        <url>http://yoursite.com/2017/06/04/hello-world/</url>
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
        
        
    </entry>
    
    
    
</search>
